// JSON DDL Scripts
USE LIBRARY_CARD_CATALOG;

// Create an Ingestion Table for JSON Data
CREATE TABLE LIBRARY_CARD_CATALOG.PUBLIC.AUTHOR_INGEST_JSON 
(
  RAW_AUTHOR VARIANT
);



//Create File Format for JSON Data
CREATE FILE FORMAT LIBRARY_CARD_CATALOG.PUBLIC.JSON_FILE_FORMAT 
TYPE = 'JSON' 
COMPRESSION = 'AUTO' 
ENABLE_OCTAL = FALSE
ALLOW_DUPLICATE = FALSE 
STRIP_OUTER_ARRAY = FALSE
STRIP_NULL_VALUES = FALSE 
IGNORE_UTF8_ERRORS = FALSE; 

-- To load the file data into separate rows, one of the values from above will need to be set to TRUE. 

list @util_db.public.like_a_window_into_an_s3_buket;

copy into LIBRARY_CARD_CATALOG.PUBLIC.AUTHOR_INGEST_JSON  
from @util_db.public.like_a_window_into_an_s3_buket
files = ( 'author_with_header.json')
file_format = ( format_name=JSON_FILE_FORMAT  );

--If you don't like what you loaded, TRUNCATE the table, modify the FILE FORMAT and load it again. 

select * from AUTHOR_INGEST_JSON;



----------------------MODIFYING FILE FORMAT---------



//Create File Format for JSON Data
CREATE or replace FILE FORMAT LIBRARY_CARD_CATALOG.PUBLIC.JSON_FILE_FORMAT 
TYPE = 'JSON' 
COMPRESSION = 'AUTO' 
ENABLE_OCTAL = FALSE
ALLOW_DUPLICATE = FALSE 
STRIP_OUTER_ARRAY = TRUE
STRIP_NULL_VALUES = FALSE 
IGNORE_UTF8_ERRORS = FALSE; 

-- To load the file data into separate rows, one of the values from above will need to be set to TRUE. 

list @util_db.public.like_a_window_into_an_s3_buket;

TRUNCATE table  LIBRARY_CARD_CATALOG.PUBLIC.AUTHOR_INGEST_JSON;

copy into LIBRARY_CARD_CATALOG.PUBLIC.AUTHOR_INGEST_JSON  
from @util_db.public.like_a_window_into_an_s3_buket
files = ( 'author_with_header.json')
file_format = ( format_name=JSON_FILE_FORMAT  );

--If you don't like what you loaded, TRUNCATE the table, modify the FILE FORMAT and load it again. 

select * from AUTHOR_INGEST_JSON;




---------

//returns AUTHOR_UID value from top-level object's attribute
select raw_author:AUTHOR_UID
from author_ingest_json;

//returns the data in a way that makes it look like a normalized table
SELECT 
 raw_author:AUTHOR_UID
,raw_author:FIRST_NAME::STRING as FIRST_NAME
,raw_author:MIDDLE_NAME::STRING as MIDDLE_NAME
,raw_author:LAST_NAME::STRING as LAST_NAME
FROM AUTHOR_INGEST_JSON;




-----------------------------

// Create an Ingestion Table for the NESTED JSON Data
CREATE OR REPLACE TABLE LIBRARY_CARD_CATALOG.PUBLIC.NESTED_INGEST_JSON 
(
  "RAW_NESTED_BOOK" VARIANT
);

-- copy into LIBRARY_CARD_CATALOG.PUBLIC.NESTED_INGEST_JSON  
-- from @util_db.public.like_a_window_into_an_s3_buket
-- files = ( 'author_with_header.json')
-- file_format = ( format_name=JSON_FILE_FORMAT  );



//a few simple queries
SELECT RAW_NESTED_BOOK
FROM NESTED_INGEST_JSON;

SELECT RAW_NESTED_BOOK:year_published
FROM NESTED_INGEST_JSON;

SELECT RAW_NESTED_BOOK:authors
FROM NESTED_INGEST_JSON;

//Use these example flatten commands to explore flattening the nested book and author data
SELECT value:first_name
FROM NESTED_INGEST_JSON
,LATERAL FLATTEN(input => RAW_NESTED_BOOK:authors);

SELECT value:first_name
FROM NESTED_INGEST_JSON
,table(flatten(RAW_NESTED_BOOK:authors));

//Add a CAST command to the fields returned
SELECT value:first_name::VARCHAR, value:last_name::VARCHAR
FROM NESTED_INGEST_JSON
,LATERAL FLATTEN(input => RAW_NESTED_BOOK:authors);

//Assign new column  names to the columns using "AS"
SELECT value:first_name::VARCHAR AS FIRST_NM
, value:last_name::VARCHAR AS LAST_NM
FROM NESTED_INGEST_JSON
,LATERAL FLATTEN(input => RAW_NESTED_BOOK:authors);